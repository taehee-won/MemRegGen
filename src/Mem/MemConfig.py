from typing import Final, Dict, Optional, Union
from argparse import Namespace
from os.path import splitext, basename

from inc import (
    InvalidArgumentTypeError,
    NotExistArgumentError,
    InvalidArgumentError,
)
from inc import Str


class MemConfig:
    _defaults: Final[Dict[str, Optional[Union[str, int]]]] = {
        # guard: str = guard is generated by MemGen file name, if bases.h, "BASES_H"
        "type": "",
        "prefix": "",
        "postfix": "",
        "array": "ch",
        "bits": 64,
        # align: int = align is set from bits if bits is 64, 16 / if bits is 32, 8
        "debug": False,
    }

    def _invalid_args(self, args: Namespace) -> None:
        # type
        for name, expected_type in [
            ["guard", str],
            ["type", str],
            ["prefix", str],
            ["postfix", str],
            ["array", str],
            ["bits", int],
            ["align", int],
            ["debug", bool],
        ]:
            if ((value := getattr(args, name, None)) is not None) and (
                not isinstance(value, expected_type)
            ):
                raise InvalidArgumentTypeError(name, value, expected_type)

        # not empty
        for name in [
            "guard",
            "array",
        ]:
            if ((value := getattr(args, name, None)) is not None) and (not value):
                raise NotExistArgumentError(
                    name,
                    f"{name} should not be empty string",
                )

        # case(upper, lower) or empty
        for name, expected_case in [
            ["guard", "upper"],
            ["type", "upper"],
            ["prefix", "upper"],
            ["postfix", "upper"],
            ["array", "lower"],
        ]:
            if ((value := getattr(args, name, None)) is not None) and (
                not value and not getattr(value, f"is{expected_case}")()
            ):
                raise InvalidArgumentError(
                    name,
                    value,
                    f"{name} should be {expected_case} cases",
                )

        # bits(64, 32)
        for name in ["bits"]:
            bits = [64, 32]
            if ((value := getattr(args, name, None)) is not None) and (
                value not in bits
            ):
                raise InvalidArgumentError(
                    name,
                    value,
                    f"{name} should be " + ", ".join([str(bit) for bit in bits]),
                )

        # limit
        for name, limit in [
            [
                "align",
                (
                    16
                    if (value := getattr(args, "bits", None)) is None or value == 64
                    else 8
                ),
            ],
        ]:
            if ((value := getattr(args, name, None)) is not None) and (
                not value < limit
            ):
                raise InvalidArgumentError(
                    name,
                    value,
                    f"{name} should less or equal than {limit}",
                )

    def _default_args(self, args: Namespace) -> None:
        for key, value in MemConfig._defaults.items():
            if getattr(args, key, None) is None:
                setattr(args, key, value)

        if args.guard is None:
            args.guard = splitext(basename(args.MemGen))[0].upper()

        if args.align is None:
            args.align = 16 if args.bits == 64 else 8

    def _set_args(self, args: Namespace) -> None:
        self._guard: str = args.guard
        self._prefix: str = args.prefix
        self._postfix: str = args.postfix
        self._type: str = args.type
        self._array: str = args.array
        self._bits: int = args.bits
        self._align: int = args.align
        self._debug: bool = args.debug

    def __init__(self, args: Namespace) -> None:
        self._invalid_args(args)
        self._default_args(args)
        self._set_args(args)

    @property
    def debug_str(self) -> str:
        return (
            Str.from_rows(
                [
                    [name, str(getattr(self, name))]
                    for name in [
                        "guard",
                        "prefix",
                        "postfix",
                        "array",
                        "bits",
                        "align",
                        "debug",
                    ]
                ],
                ": ",
            )
            .insert_guard("-")
            .insert_line("MemConfig")
            .add_guard("=")
            .contents
        )

    @property
    def guard(self) -> str:
        return self._guard

    @property
    def prefix(self) -> str:
        return self._prefix

    @property
    def postfix(self) -> str:
        return self._postfix

    @property
    def type(self) -> str:
        return self._type

    @property
    def array(self) -> str:
        return self._array

    @property
    def bits(self) -> int:
        return self._bits

    @property
    def align(self) -> int:
        return self._align

    @property
    def debug(self) -> bool:
        return self._debug
